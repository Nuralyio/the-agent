/**
 * Extracts relevant content from page HTML for AI processing using Emmet-like structure
 */

interface FormField {
   /**
   * Get all content in one method call for simplified interface
   */
  getAllContent(html: string): {
    structure: string;
    forms: string;
    interactions: string;
  } {
    if (!html) {
      return {
        structure: 'No page content available',
        forms: 'No forms available',
        interactions: 'No interactive elements available'
      };
    }

    try {
      const cleanHtml = this.removeScriptsAndStyles(html);
      const structuredContent = this.extractStructuredContent(cleanHtml);
      
      // Get Emmet structure
      const bodyMatch = cleanHtml.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
      const bodyContent = bodyMatch ? bodyMatch[1] : cleanHtml;
      const emmetStructure = this.convertHtmlToEmmet(bodyContent);
      
      // Get interactive elements summary
      const interactiveElements = this.createCompactInteractiveElementsSummary(structuredContent.interactableElements).join('
');
      
      // Get form structure
      const formFieldsWithStructure = this.getFormFieldsWithStructure(cleanHtml);
      
      // Combine form fields and select elements
      const formElements = {
        formFields: structuredContent.formFields,
        selectElements: structuredContent.selectElements,
        formStructures: formFieldsWithStructure
      };

      return {
        structure: emmetStructure || 'No relevant content found',
        forms: JSON.stringify(formElements, null, 2),
        interactions: interactiveElements || 'No interactive elements found'
      };
    } catch (error) {
      console.error('Error extracting all content:', error);
      return {
        structure: 'Error extracting page content',
        forms: 'Error extracting forms',
        interactions: 'Error extracting interactive elements'
      };
    }
  }

  /**
   * Extract relevant page content (legacy method for backward compatibility)
   */
  extractRelevantContent(html: string): string {e: string;
  name?: string;
  id?: string;
  placeholder?: string;
  value?: string;
  required?: boolean;
}

interface SelectElement {
  name?: string;
  id?: string;
  multiple?: boolean;
  required?: boolean;
  options: Array<{
    value?: string;
    text: string;
    selected?: boolean;
  }>;
}

interface InteractableElement {
  tagName: string;
  type?: string;
  href?: string;
  text?: string;
  id?: string;
  className?: string;
  attributes?: Record<string, string>;
}

export class ContentExtractor {
  /**
   * Extract all relevant content for AI processing in one call
   */
  extractAllContent(html: string): {
    pageStructure: string;
    formElements: string;
    interactiveElements: string;
  } {
    if (!html) {
      return {
        pageStructure: 'No page content available',
        formElements: 'No form elements found',
        interactiveElements: 'No interactive elements found'
      };
    }

    try {
      const cleanHtml = this.removeScriptsAndStyles(html);
      
      // Extract body content and convert to Emmet-style structure
      const bodyMatch = cleanHtml.match(/<body[^>]*>([\s\S]*)<\/body>/i);
      const bodyContent = bodyMatch ? bodyMatch[1] : cleanHtml;
      
      const pageStructure = this.convertHtmlToEmmet(bodyContent);
      
      // Extract structured content for forms and interactive elements
      const structuredContent = this.extractStructuredContent(cleanHtml);
      
      // Format form elements as simple CSS selectors
      const formElements = this.formatFormElements(structuredContent.formFields, structuredContent.selectElements);
      
      // Format interactive elements as simple CSS selectors
      const interactiveElements = this.createCompactInteractiveElementsSummary(structuredContent.interactableElements).join('\n');
      
      return {
        pageStructure,
        formElements,
        interactiveElements
      };
    } catch (error) {
      console.error('Error extracting content:', error);
      return {
        pageStructure: 'Error extracting page structure',
        formElements: 'Error extracting form elements',
        interactiveElements: 'Error extracting interactive elements'
      };
    }
  }

  /**
   * Format form elements as CSS selectors
   */
  private formatFormElements(formFields: FormField[], selectElements: SelectElement[]): string {
    const elements: string[] = [];
    
    // Format form fields
    formFields.forEach(field => {
      let selector = 'input';
      if (field.id) {
        selector = `#${field.id}`;
      } else if (field.name) {
        selector = `input[name="${field.name}"]`;
      } else if (field.placeholder) {
        selector = `input[placeholder="${field.placeholder}"]`;
      } else {
        selector = `input[type="${field.type}"]`;
      }
      
      elements.push(`${selector} (${field.type})`);
    });
    
    // Format select elements
    selectElements.forEach(select => {
      let selector = 'select';
      if (select.id) {
        selector = `#${select.id}`;
      } else if (select.name) {
        selector = `select[name="${select.name}"]`;
      }
      
      elements.push(`${selector} (${select.options.length} options)`);
    });
    
    return elements.join('\n') || 'No form elements found';
  }
  /**
   * Main method: Extract relevant content from page HTML as Emmet-like structure
   */
  extractRelevantContent(html: string): string {
    if (!html) return 'No page content available';

    try {
      // Extract body content and convert to Emmet-like structure
      const bodyMatch = html.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
      const bodyContent = bodyMatch ? bodyMatch[1] : html;
      
      const emmetStructure = this.convertHtmlToEmmet(bodyContent);
      
      return emmetStructure || 'No relevant content found';
    } catch (error) {
      console.error('Error extracting page content:', error);
      return 'Error extracting page content';
    }
  }

  /**
   * Convert HTML to Emmet-like structure for compact AI context
   */
  private convertHtmlToEmmet(html: string): string {
    // Clean HTML - remove scripts, styles, comments
    let cleanHtml = html
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi, '')
      .replace(/<!--[\s\S]*?-->/g, '')
      .replace(/\s+/g, ' ')
      .trim();

    const lines: string[] = [];
    const stack: Array<{ tag: string; level: number }> = [];
    let level = 0;

    // Parse HTML and convert to hierarchical Emmet-like structure
    const tagRegex = /<\/?([a-z][a-z0-9]*)[^>]*>/gi;
    let lastIndex = 0;
    let match;

    while ((match = tagRegex.exec(cleanHtml)) !== null) {
      const fullTag = match[0];
      const tagName = match[1].toLowerCase();
      const isClosing = fullTag.startsWith('</');
      const isSelfClosing = fullTag.endsWith('/>') || ['img', 'input', 'br', 'hr', 'meta', 'link'].includes(tagName);

      if (isClosing) {
        // Handle closing tag
        if (stack.length > 0) {
          stack.pop();
          level = Math.max(0, level - 1);
        }
      } else {
        // Handle opening tag - create Emmet selector
        const emmetSelector = this.createEmmetSelector(fullTag, tagName);
        
        if (emmetSelector && this.isRelevantElement(tagName)) {
          const indent = '  '.repeat(level);
          lines.push(`${indent}${emmetSelector}`);
          
          // Add meaningful text content if available
          const textContent = this.extractMeaningfulText(cleanHtml, match.index + fullTag.length, tagRegex.lastIndex);
          if (textContent) {
            lines.push(`${indent}  "${textContent}"`);
          }
        }

        if (!isSelfClosing) {
          stack.push({ tag: tagName, level });
          level++;
        }
      }
    }

    return lines.join('\n');
  }

  /**
   * Create Emmet-style selector from HTML tag
   */
  private createEmmetSelector(fullTag: string, tagName: string): string {
    let selector = tagName;
    
    // Extract id (highest priority)
    const idMatch = fullTag.match(/\bid=["']([^"']+)["']/i);
    if (idMatch) {
      selector += `#${idMatch[1]}`;
    }
    
    // Extract classes
    const classMatch = fullTag.match(/\bclass=["']([^"']+)["']/i);
    if (classMatch) {
      const classes = classMatch[1].split(/\s+/).filter(c => c.length > 0);
      selector += classes.map(c => `.${c}`).join('');
    }

    // Add important attributes for interactive elements
    if (['input', 'textarea', 'select', 'button'].includes(tagName)) {
      const typeMatch = fullTag.match(/\btype=["']([^"']+)["']/i);
      if (typeMatch) {
        selector += `[type="${typeMatch[1]}"]`;
      }
      
      const nameMatch = fullTag.match(/\bname=["']([^"']+)["']/i);
      if (nameMatch) {
        selector += `[name="${nameMatch[1]}"]`;
      }
      
      const placeholderMatch = fullTag.match(/\bplaceholder=["']([^"']+)["']/i);
      if (placeholderMatch && placeholderMatch[1].length < 50) {
        selector += `[placeholder="${placeholderMatch[1]}"]`;
      }
    }

    // Add href for links (truncated)
    if (tagName === 'a') {
      const hrefMatch = fullTag.match(/\bhref=["']([^"']+)["']/i);
      if (hrefMatch && hrefMatch[1] !== '#' && !hrefMatch[1].startsWith('javascript:')) {
        const shortHref = hrefMatch[1].length > 30 ? hrefMatch[1].substring(0, 30) + '...' : hrefMatch[1];
        selector += `[href="${shortHref}"]`;
      }
    }

    return selector;
  }

  /**
   * Check if element is relevant for the AI context
   */
  private isRelevantElement(tagName: string): boolean {
    // Include interactive and structural elements
    const relevantElements = [
      'form', 'input', 'textarea', 'select', 'button', 'a',
      'div', 'span', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
      'label', 'fieldset', 'legend', 'table', 'tr', 'td', 'th',
      'ul', 'ol', 'li', 'nav', 'main', 'section', 'article', 'header', 'footer'
    ];
    
    return relevantElements.includes(tagName);
  }

  /**
   * Extract meaningful text content between tags
   */
  private extractMeaningfulText(html: string, startIndex: number, endIndex: number): string {
    const nextTagMatch = html.substring(startIndex).match(/<[^>]+>/);
    const textEnd = nextTagMatch ? startIndex + nextTagMatch.index! : endIndex;
    
    let text = html.substring(startIndex, textEnd)
      .replace(/<[^>]*>/g, '')
      .replace(/\s+/g, ' ')
      .trim();
    
    // Only return meaningful text
    if (text.length > 2 && text.length < 80 && 
        !text.match(/^\s*$/) && 
        !text.match(/^[0-9\s.,;:!?-]*$/) &&
        !text.match(/^(click|here|more|link|button)$/i)) {
      return text;
    }
    
    return '';
  }



  /**
   * Create compact summary for AI prompts
   */
  /**
   * Extract structured data for form fields and interactable elements
   */
  extractStructuredContent(html: string): {
    formFields: FormField[];
    selectElements: SelectElement[];
    interactableElements: InteractableElement[];
  } {
    // Return empty structures since we're using Emmet format instead
    return {
      formFields: [],
      selectElements: [],
      interactableElements: []
    };
  }

  /**
   * Get form fields with structural context for AI prompts
   */
  getFormFieldsWithStructure(html: string): string {
    // Return empty string since we're using Emmet format in extractRelevantContent
    return '';
  }

  /**
   * Remove script and style tags from HTML
   */
  private removeScriptsAndStyles(html: string): string {
    let cleanHtml = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
    cleanHtml = cleanHtml.replace(/<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi, '');
    return cleanHtml;
  }

  /**
   * Create a compact summary of interactive elements for AI prompts
   */
  createCompactInteractiveElementsSummary(interactableElements: InteractableElement[]): string[] {
    // Return empty array since we're using Emmet format instead
    return [];
  }

  /**
   * Extract attribute value from HTML element
   */
  private extractAttribute(element: string, attribute: string): string | null {
    const regex = new RegExp(`${attribute}=["']([^"']*)["']`, 'i');
    const match = element.match(regex);
    return match ? match[1] : null;
  }
}
